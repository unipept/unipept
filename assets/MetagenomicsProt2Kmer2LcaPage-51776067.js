import{I as a}from"./InlineCode-b941903d.js";import{H as d}from"./HeaderBodyCard-f3b47b61.js";import{I as l}from"./Initialism-25eec5f3.js";import{B as s,S as i}from"./Boxed-1ca540a2.js";import{_ as m}from"./ParameterTable.vue_vue_type_script_setup_true_lang-ea4e3ff2.js";import{d as c,k as h,o as p,c as _,w as o,l as f,g as t,b as e,a as n}from"./index-fa2d734a.js";import{V as g}from"./VDivider-7dfa9365.js";import"./_plugin-vue_export-helper-c27b6911.js";import"./VCard-4d112d66.js";import"./VRow-781382bd.js";const b=t("h1",{class:"font-weight-light"}," umgap prot2kmer2lca ",-1),k={class:"font-weight-light"},y=t("i",null,"standard input",-1),w=t("i",null,"standard output",-1),x=t("b",null,"cat input.fa",-1),A=t("br",null,null,-1),v=t("br",null,null,-1),T=t("br",null,null,-1),B=t("b",null,"umgap prot2kmer2lca -k9 uniprot-2020-04-9mer.index < input.fa",-1),S=t("br",null,null,-1),I=t("br",null,null,-1),V=t("br",null,null,-1),C=t("br",null,null,-1),D=t("br",null,null,-1),N=t("br",null,null,-1),F=t("br",null,null,-1),P=t("b",null,"umgap prot2kmer2lca -o uniprot-2020-04-9mer.index < input.fa",-1),q=t("br",null,null,-1),K=t("br",null,null,-1),L=t("br",null,null,-1),U=t("br",null,null,-1),$=t("br",null,null,-1),z=t("br",null,null,-1),M=t("br",null,null,-1),R=t("br",null,null,-1),W=t("br",null,null,-1),oe=c({__name:"MetagenomicsProt2Kmer2LcaPage",setup(G){const r=[{name:"-h / --help",description:"Prints help information"},{name:"-V / --version",description:"Prints version information"},{name:"-m / --in-memory",description:"Load index in memory instead of memory mapping the file contents. This makes querying significantly faster, but requires some initialization time."},{name:"-o / --one-on-one",description:"Map unknown sequences to 0 instead of ignoring them"},{name:"-c / --chunksize c",description:"Number of reads grouped into one chunk. Bigger chunks decrease the overhead caused by multithreading. Because the output order is not necessarily the same as the input order, having a chunk size which is a multiple of 12 (all 6 translations multiplied by the two paired-end reads) will keep FASTA records that originate from the same reads together [default: 240]"},{name:"-l / --length l",description:"The length of the k-mers in the index [default: 9]"},{name:"-s / --socket s",description:"Instead of reading from stdin and writing to stdout, create a Unix socket to communicate with using OpenBSD's netcat (nc -NU socket). This is especially useful in combination with the --in-memory flag: you only have to load the index in memory once, after which you can query it without having the loading time overhead each time"}];return(H,O)=>{const u=h("RLink");return p(),_(f,null,{default:o(()=>[b,t("h3",k,[e(" Maps all k-mers from a "),n(l,null,{default:o(()=>[e("FASTA")]),_:1}),e(" stream of peptides to taxon IDs. ")]),n(g,{class:"my-2"}),t("p",null,[e(" The "),n(a,null,{default:o(()=>[e("umgap prot2kmer2lca")]),_:1}),e(" command takes one or more peptides as input and outputs the lowest common ancestors of all their k-mers. It is a combination of the "),n(a,null,{default:o(()=>[e("umgap prot2kmer")]),_:1}),e(" and "),n(a,null,{default:o(()=>[e("umgap pept2lca")]),_:1}),e(" commands to allow more efficient parallel computing. ")]),n(d,{id:"usage",title:"Usage","large-title":""},{default:o(()=>[t("p",null,[e(" The input is given in a "),n(l,null,{default:o(()=>[e("FASTA")]),_:1}),e(" format on "),y,e(", with a single peptide per "),n(l,null,{default:o(()=>[e("FASTA")]),_:1}),e(" header, which may be hardwrapped with newlines. All overlapping k-mers in these peptides (k configurable via the "),n(a,null,{default:o(()=>[e("-k")]),_:1}),e(" option, and 9 by default) are searched for in the index (as build by the "),n(a,null,{default:o(()=>[e("umgap buildindex")]),_:1}),e(" command) passed as argument. The results are printed on "),w,e(" in "),n(l,null,{default:o(()=>[e("FASTA")]),_:1}),e(" format. ")]),n(s,{style:{"max-height":"fit-content"}},{default:o(()=>[n(i,null,{default:o(()=>[e("$")]),_:1}),e(),x,A,e(">header1 "),v,e("DAIGDVAKAYKKAG*S "),T,n(i,null,{default:o(()=>[e("$")]),_:1}),e(),B,S,e(">header1 "),I,e("571525 "),V,e("571525 "),C,e("6920 "),D,e("6920 "),N,e("1 "),F,e("6920 ")]),_:1}),t("p",null,[e(" Add the "),n(a,null,{default:o(()=>[e("-o")]),_:1}),e(" option to print out 0 for k-mers not found in the index. ")]),n(s,null,{default:o(()=>[n(i,null,{default:o(()=>[e("$")]),_:1}),e(),P,q,e(">header1 "),K,e("571525 "),L,e("571525 "),U,e("6920 "),$,e("6920 "),z,e("1 "),M,e("6920 "),R,e("0 "),W,e("0 ")]),_:1}),t("p",null,[e(" This command also allows an alternative mode of operation. When memory mapped, it can take some time for the index to be searched. With the "),n(a,null,{default:o(()=>[e("-m")]),_:1}),e(" flag, the complete index will be loaded in memory before operation. This, too, takes some time, but for a single large analysis, this impact is irrelevant compared to the time of analysis. When processing many short files, the index would need to be loaded again and again. Instead of using this command as part of a pipeline, "),n(a,null,{default:o(()=>[e("... | umgap prot2kmer2lca index | ...")]),_:1}),e(", it can run in a separate (and persistent) process, reusing the same loaded index. Run "),n(a,null,{default:o(()=>[e("umgap prot2kmer2lca -m -s umgap-socket index")]),_:1}),e(" as a service, and when the index is loaded, change your original pipeline(s) to communicate with the socket using "),n(u,{to:"http://man.openbsd.org/nc"},{default:o(()=>[e("OpenBSD's netcat")]),_:1}),e(": "),n(a,null,{default:o(()=>[e("... | nc -NU /path/to/umgap-socket | ...")]),_:1}),e(". ")]),n(m,{class:"mt-5 mb-3",parameters:r})]),_:1})]),_:1})}}});export{oe as default};
