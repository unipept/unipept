#!/usr/bin/env ruby
require 'cri'

Signal.trap("PIPE", "EXIT")
Signal.trap("INT", "EXIT")
root_cmd = Cri::Command.new_basic_root.modify do
  name 'prot2pept'
  required :p, :pattern, "cleavage pattern to split input protein (default: ([KR])([^P]))"
  run do |opts, args, cmd|
    pattern = opts.fetch(:pattern, "([KR])([^P])")
    # decide if we have FASTA input
    fasta_header = gets
    if fasta_header.start_with? '>'
      # fasta input, need to join lines
      while !$stdin.eof?
        prot = ""
        # Sometimes you just got to accept this weird and ugly code
        until $stdin.eof? || (line = gets).start_with?('>')
          prot += line.chomp
        end
        puts fasta_header
        puts prot.gsub(/#{pattern}/,"\\1\n\\2").gsub(/#{pattern}/, "\\1\n\\2").split("\n").reject(&:empty?)

        fasta_header = line
      end
    else
      # handle our already read line
      puts fasta_header.gsub(/#{pattern}/,"\\1\n\\2").gsub(/#{pattern}/, "\\1\n\\2").split("\n").reject(&:empty?)

      # we no longer have to join lines as input is now more sane
      $stdin.each_line do |prot|
        puts prot.gsub(/#{pattern}/,"\\1\n\\2").gsub(/#{pattern}/, "\\1\n\\2").split("\n").reject(&:empty?)
      end
    end
  end
end

root_cmd.run(ARGV)
